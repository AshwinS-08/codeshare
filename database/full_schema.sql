-- ========================================
-- API App Database Schema for Supabase
-- ========================================

-- 1. Enable UUID extension if not already enabled
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. Create Shares Table
DROP TABLE IF EXISTS shares CASCADE;
CREATE TABLE IF NOT EXISTS shares (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code VARCHAR(10) NOT NULL UNIQUE,
    content_type VARCHAR(10) NOT NULL CHECK (content_type IN ('text', 'file')),
    text_content TEXT,
    file_name VARCHAR(255),
    file_size BIGINT,
    file_url TEXT,
    is_protected BOOLEAN DEFAULT FALSE,
    password_hash TEXT,
    view_count INTEGER DEFAULT 0,
    max_views INTEGER, -- Optional limit on views
    user_id UUID REFERENCES auth.users(id), -- Links to Supabase Auth user
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,
    metadata JSONB DEFAULT '{}'::jsonb,
    language VARCHAR(50)
);

-- 3. Create Indexes
CREATE INDEX IF NOT EXISTS idx_shares_code ON shares(code);
CREATE INDEX IF NOT EXISTS idx_shares_user_id ON shares(user_id);
CREATE INDEX IF NOT EXISTS idx_shares_created_at ON shares(created_at);

-- 4. Row Level Security (RLS)
ALTER TABLE shares ENABLE ROW LEVEL SECURITY;

-- Policy: Anyone can view shares (via RPC or if they know the code - logic handled in app/RPC)
-- But for direct table access, we might want to restrict.
-- Let's allow public read for now, but the app uses RPC for view counting.
CREATE POLICY "Public shares are viewable by everyone" 
ON shares FOR SELECT 
USING (true);

-- Policy: Authenticated users can insert their own shares
CREATE POLICY "Users can insert their own shares" 
ON shares FOR INSERT 
TO authenticated 
WITH CHECK (auth.uid() = user_id);

-- Policy: Anon users can insert shares (if we allow anon sharing)
CREATE POLICY "Anon can insert shares" 
ON shares FOR INSERT 
TO anon 
WITH CHECK (true);

-- Policy: Users can update their own shares (e.g. deactivate)
CREATE POLICY "Users can update their own shares" 
ON shares FOR UPDATE 
TO authenticated 
USING (auth.uid() = user_id);

-- 5. RPC Function: get_share_by_code
-- This function retrieves the share and increments the view count atomically.
DROP FUNCTION IF EXISTS get_share_by_code(text) CASCADE;
DROP FUNCTION IF EXISTS get_share_by_code(_code text) CASCADE;
CREATE OR REPLACE FUNCTION get_share_by_code(share_code TEXT)
RETURNS TABLE (
    id BIGINT,
    code VARCHAR,
    content_type VARCHAR,
    text_content TEXT,
    file_name VARCHAR,
    file_size BIGINT,
    file_url TEXT,
    is_protected BOOLEAN,
    password_hash TEXT,
    view_count INTEGER,
    max_views INTEGER,
    created_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN,
    metadata JSONB,
    language VARCHAR,
    user_id UUID
)
LANGUAGE plpgsql
SECURITY DEFINER -- Runs with privileges of the creator (bypass RLS for the update)
AS $$
BEGIN
    -- Increment view count
    UPDATE shares 
    SET view_count = view_count + 1 
    WHERE code = UPPER(share_code) 
    AND (expires_at IS NULL OR expires_at > NOW())
    AND (max_views IS NULL OR view_count < max_views)
    AND is_active = TRUE;
    
    -- Return the share record
    RETURN QUERY
    SELECT 
        s.id,
        s.code,
        s.content_type,
        s.text_content,
        s.file_name,
        s.file_size,
        s.file_url,
        s.is_protected,
        s.password_hash,
        s.view_count,
        s.max_views,
        s.created_at,
        s.expires_at,
        s.is_active,
        s.metadata,
        s.language
    FROM shares s
    WHERE s.code = UPPER(share_code) 
    AND (s.expires_at IS NULL OR s.expires_at > NOW())
    AND (s.max_views IS NULL OR s.view_count <= s.max_views) -- Allow viewing the last one that hit the limit? Or strictly < ? 
    -- Usually if view_count was incremented to max_views, it's still viewable this time.
    -- If view_count was ALREADY max_views, the UPDATE above wouldn't happen (if we added check there).
    -- Let's refine the logic:
    -- We want to allow access if it WAS valid before this call.
    -- The UPDATE increments. So if max is 5, and current is 4. Update makes it 5. Return it.
    -- Next call: current is 5. Update condition "view_count < max_views" (5 < 5) is False. No update.
    -- Select condition: we should probably return it if it's still valid or if we just viewed it.
    -- But if no update happened, maybe we shouldn't return it?
    -- Let's keep it simple: Return if is_active and not expired. The view count limit is a soft limit or hard limit?
    -- If hard limit, we should hide it.
    AND is_active = TRUE;
END;
$$;

-- 6. Storage Bucket Setup (Instructions)
-- You typically need to create the bucket via the Supabase Dashboard.
-- Bucket Name: 'shared-files'
-- Public: false (or true if you want direct public access, but code uses signed URLs/proxy)
-- RLS Policies for Storage:
-- INSERT: authenticated users (and anon if allowed)
-- SELECT: public (or authenticated only)

-- 7. Activities Table (for Analytics)
DROP TABLE IF EXISTS activities CASCADE;
CREATE TABLE IF NOT EXISTS activities (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    share_id BIGINT REFERENCES shares(id),
    action_type VARCHAR(50) NOT NULL, -- 'CREATE', 'VIEW', 'DOWNLOAD'
    details JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes for activities
CREATE INDEX IF NOT EXISTS idx_activities_user_id ON activities(user_id);
CREATE INDEX IF NOT EXISTS idx_activities_created_at ON activities(created_at);

-- RLS for activities
ALTER TABLE activities ENABLE ROW LEVEL SECURITY;

-- Users can view their own activities
CREATE POLICY "Users can view their own activities" 
ON activities FOR SELECT 
TO authenticated 
USING (auth.uid() = user_id);

-- System can insert activities (handled by backend service role usually, but if RLS applies)
-- We'll rely on backend using service role or explicit insert policies if needed.
-- For now, allow authenticated users to insert their own activities (e.g. if we moved logic to frontend, but we are doing it in backend)

